\parttitletext{
\thispagestyle{empty}
\begin{enumerate}
  \item Описание возможностей AniFem++
  {\normalsize
  \begin{itemize}
  	\item Квадратурные формулы
  	\item Конечные элементы
  	\item Элементная матрица
  	\item Вычисление КЭ функции в точке
  	\item Наложение условий Дирихле
	\end{itemize}
  }
  \item Примеры использования
  {\normalsize
  \begin{itemize}
  	\item Первое знакомство
  	\item Стационарное уравнение реакции-диффузии
  	\item Стационарный изгиб балки
  	\item Стационарное уравнение Стокса
  	\item Нестационарное уравнение конвекции-диффузии
	\end{itemize}
  }
\end{enumerate} 

}

\part{Вычислительная платформа Anifem++}  
Данная инструкция состоит из двух частей: в первой части приводится обзор основных элементов и возможностей Anifem++, а вторая часть представлена ввиде набора постепенно усложняющихся примеров, которые призваны научить использовать данную библиотеку. Если вы были ранее знакомы с библиотекой Ani3D/AniFem, то можете начинать знакомство сразус написания кода.





\chapter{Описание AniFem++} 
Основными элементами библиотеки AniFem++ являются:
\begin{itemize}
\item множество квадратурных формул;
\item классы с описанием используемых КЭ пространств;
\item функции для вычисления элементных матриц;
\item функции вычисления КЭ функции в точке;
\item функции для наложения граничных условий Дирихле.
\end{itemize}

Последовательно рассмотирим каждый из этих элементов.

\section{Квадратурные формулы}
Для численной аппроксимации возникающих при КЭ дискретизации интегралов реализованы квадратурные формулы вида $w^i, {\lambda^i}^N_{i=1}$:
\[
\int_{S_d}f(x)dx \approx |S_d|\sum_{i=1}^N w^i f\left(\sum_{k=1}^{d+1}\lambda_k^ip_k \right),
\]
где $\lambda$ - барицентрические координаты точки внутри $d$-мерного симплекса $S_d$ с опорными точками $\bm{p}_k$. Формулы реализованы вплоть до 20-го порядка для 1D, 2D и 3D симлпексов(для отрезков, треугольников, тетраэдров), имеют узла только внутри симлпексов ($\lambda_k^i>0$) и только положительные веса ($w^i>0$).

Функции для получения квадратур, см. quadrature\_formulas.h:
\begin{lstlisting}
TetraQuadFormula    tetrahedron_quadrature_formulas(int order);
TriangleQuadFormula triangle_quadrature_formulas(   int order);
SegmentQuadFormula  segment_quadrature_formulas(    int order);
\end{lstlisting}

Ввиду реализации формул целиком через статическую память, вызов этих функций является дешевой операцией.

\section{Конечные элементы}
В рамках AniFem++ конечные элементы имеют 2 вариант реализации: compile-time (через шаблоны) и runtime (через наследование).

Исходно предоставляется следующий набор КЭ пространств (хотя можно определять и собственные пространства):

\begin{table}
\begin{tabular}{|p{5cm}|p{3cm}|p{2cm}|}
\hline
Базовые пространства & compile-time представление & runtime представление\\
\hline
piecewise constant, $P_0$ & FemFix<FEM\_P0> & P0Space\\
\hline
continuous picewise linear, $P_1$ & FemFix<FEM\_P1> & P1Space\\
\hline
continuous picewise quadratic, $P_2$ & FemFix<FEM\_P2> & P2Space\\
\hline
continuous picewise cubic, $P_3$ & FemFix<FEM\_P3> & P3Space\\
\hline
the lowest order Nedelec (edge) finite element & FemFix<FEM\_ND0> & ND0Space\\
\hline
the lowest order Raviart-Thomas (face) finite element & FemFix<FEM\_RT0> & RT0Space\\
\hline
the Crouzeix-Raviart fintie element & FemFix<FEM\_CR1> & CR1Space\\
\hline
Bubble subspace, 4-order cell-centred basis fucntion, incomplete space & FemFix<FEM\_B4> & BubbleSpace\\
\hline
\end{tabular}
\end{table}

Важно отметить что BubbleSpace не является завершенным КЭ пространством а лишь содержит единственную базисную функцию $\phi = \lambda_1\lambda_2\lambda_3\lambda_4$ и предоставляется для обогащения других пространств.

\begin{table}
\begin{tabular}{|p{3cm}|p{3.5cm}|p{3.5cm}|}
\hline
Операции над пространствами & compile-time пример & runtime пример\\
\hline
определение пространства & using P1Fem = FemFix<FEM\_P1>; using P2Fem = FemFix<FEM\_P2> & FemSpace P1\{P1Space()\}, P2\{P2Space()\}, B4\{BubbleSpace()\};\\
\hline
декартово произведение, $\times$ & FemCom<P1Fem, P2Fem, P1Fem> & P1*P2*P1\\
\hline
возведение в натуральную степень, $\wedge$k & FemVecT<3, P1Fem> & (P1$\wedge$ 3)\\
\hline
обогащение пространства, $+$ & недоступно & P1+B4\\
\hline
\end{tabular}
\end{table}

Все пространства предоставляют функторы для вычисления действия следующих линейных дифференциальных операторов (если они математически определены) на базисные функции:

\begin{table}
\begin{tabular}{|p{4cm}|p{4cm}|}
\hline
Имя оператора & Описание \\
\hline
IDEN & тождественный оператор, IDEN($v^h$) = $v^h$ \\
\hline
GRAD & оператор градиента, GRAD($v^h$) = $\nabla v^h$ \\
\hline
DIV & оператор дивергенции, DIV($v^h$) = $\div v^h$ \\
\hline
CURL & оператор ротора, CURL($v^h$) = $\rot v^h$ \\
\hline
DUDX & частная производная в x-направлении, DUDX($v^h$) = $\partial v^h/\partial x$ \\
\hline
DUDY & частная производная в y-направлении, DUDY($v^h$) = $\partial v^h/\partial y$ \\
\hline
DUDZ & частная производная в z-направлении, DUDZ($v^h$) = $\partial v^h/\partial z$ \\
\hline
\end{tabular}
\end{table}

Также в runtime режиме у класса FemSpace есть метод

\begin{lstlisting}
 void evalBasisFunctions(const Expr& lmb, const Expr& grad_lmb, std::vector<Expr>& phi);
\end{lstlisting}
который можно использовать для символьного вычисления действия любых линейных дифференциальных операторов на элементные базисные функции.

Конечные элементы в AniFem++ представлены следующим набором:
\begin{itemize}
\item функторы для вычисления действия дифференциальных операторов на множество элементных базисных функций КЭ пространства, Op($\phi$);
\item отображение элементных степеней свободы на элементы тетраэдра DofMap;
\item функции интерполяции гладких функций на отдельные степени свободы, $I_i(f)$ или степени свободы, лежащие на определенной части тетраэдра, $I_g(f)$.
\end{itemize}

\begin{table}
\begin{tabular}{|p{3cm}|p{3.5cm}|p{3.5cm}|}
\hline
Операции над пространствами UFem & compile-time пример & runtime пример\\
\hline
получить функтор $Op(\phi)$, в примерах $Op =$ GRAD & Operator<GRAD, UFem> & UFem.getOP(GRAD)\\
\hline
получить DofMap & Dof<UFem>::Map() & UFem.dofMap()\\
\hline
вычислить $I_i(f)$ & Dof<UFem>::interpolate(tetra, f, dof\_vals, idof\_on\_tet) & UFem.interpolateOnDOF(tetra, f, dof\_vals, idof\_on\_tet, wmem)\\
\hline
вычислить $I_g(f)$ & interpolateByDOFs<UFem>(tetra, f, dof\_vals, tet\_part) & UFem.interpolateByDOFs(tetra, f, dof\_vals, tet\_part, wmem)\\
\hline
\end{tabular}
\end{table}